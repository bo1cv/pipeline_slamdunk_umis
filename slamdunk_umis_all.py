"""===========================
Pipeline slamdunk_all.py
===========================

Overview
========

This pipeline computes conversion Rate from fastq SLAM-seq data
files :file:``pipeline.yml` and :file:`conf.py`.

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.
CGATReport report requires a :file:`conf.py` and optionally a
:file:`cgatreport.ini` file (see :ref:`PipelineReporting`).

Default configuration files can be generated by executing:

   python <srcdir>/slamdunk_all.py config

Input files
-----------

Input reads must be the lone present in the cwd with suffix ".fastq.gz"
Input reads names should have the following structure:
cellline-timepointinhours-R#(replicate number)
example: mESC-3h-R1.fastq.gz

The pipeline configuration files.

Requirements
------------

On top of the default CGAT setup, the pipeline requires the following
software to be in the path:

.. Add any additional external requirements such as 3rd party software
   or R modules below:

Requirements:

slamdunk

Pipeline output
===============

.. Describe output files of the pipeline here

Glossary
========

.. glossary::


Code
====

"""

import sys
import os
import sqlite3
import csv
import re
import glob

from cgatcore import pipeline as P
import cgat.GTF as GTF
import cgatcore.iotools as IOTools
from ruffus import *

#Load config file options
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])
########################

@transform("*.fastq.gz",
           regex("(.+).fastq.gz"),
           r"\1_processed.fastq.gz")
def umi_extract(infile, outfile):
    '''moves the UMI from the read to the read name'''
    n_threads = PARAMS["number_of_threads"]
    log_file = P.snip(outfile, ".fastq.gz")+".log"
    job_memory="4G"
    statement = '''
    umi_tools extract --stdin=%(infile)s --bc-pattern=NNNNNN --log=%(log_file)s --stdout %(outfile)s
    '''
    P.run(statement,
          job_memory="4G")

def make_conf(outfile, list_samples, pattern):
    '''Creates the slamdunk sample file.
    The sample file has four columns:
    1. Filename
    2. Sample name. This is currently the filename with the .fastq.gz removed
    3. is "chase"
    4. time point in minutes. This is retreived from the file anme assuming [A-Za-z]-(.+)h-R[0-9]'''
    
    with open(outfile, 'w', newline='') as f_output:
        tsv_output = csv.writer(f_output, delimiter='\t')
        for i in list_samples:
            samples_grouping = re.search(pattern,i)
            if samples_grouping is None:
                tsv_output.writerow((i, i[:-9], "chase", 0))
            else:
                tsv_output.writerow((i, i[:-9], "chase", float(samples_grouping.groups()[0]) * 60))

@originate("sample_description.tsv")
def make_config_file(outfile):
    ''' this takes the reads input names and outputs them to a tsv of filenames for slamdunk all'''
    list_samples = glob.glob('*_{}'.format("*processed.fastq.gz"))
    pattern = "[A-Za-z0-9]+-(.+)h-R[0-9]_processed.fastq.gz"
    make_conf(outfile, list_samples, pattern)



@follows(mkdir("map"))
@split([make_config_file, umi_extract],
       ["map/{}_slamdunk_mapped.bam".format(P.snip(sample, ".fastq.gz"))
        for sample in glob.glob('*processed.fastq.gz')])
def slamdunk_map(infiles, outfiles):
    '''slamdunk map dunk'''
    
    infiles = infiles[0]
    genome_file = os.path.abspath(
        os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
    bed_file = PARAMS["bed_file_dir"]
    n_threads = PARAMS["number_of_threads"]
    five_trimming = PARAMS["5_trimming"]
    multi_ali = PARAMS["max_alignments_per_read"]
    out_dir = os.getcwd()
    job_memory = "4G"
    statement = '''
    slamdunk map -r %(genome_file)s 
                 -o %(out_dir)s 
                 -5 %(five_trimming)s 
                 -n %(multi_ali)s 
                 -t %(n_threads)s 
                 --skip-sam %(infiles)s
    '''
    P.run(statement,
          job_memory="4G",
          job_threads=n_threads)

@follows(mkdir("filter"))
@transform(slamdunk_map,
           regex("map/(.+)_slamdunk_mapped.bam"),
           r"filter/\1_slamdunk_mapped_filtered.bam")
def slamdunk_filter(infiles, outfiles):
    '''slamdunk filter dunk'''
    bed_file = PARAMS["bed_file_dir"]
    n_threads = PARAMS["number_of_threads"]
    mismatch = PARAMS["nm_mismatch"]
    out_dir = os.getcwd()+"/filter"
    job_memory="4G"
    statement = '''
    slamdunk filter -b %(bed_file)s 
                    -o %(out_dir)s 
                    -t %(n_threads)s 
                    -nm %(mismatch)s 
                    %(infiles)s
    '''
    P.run(statement,
          job_memory="4G",
          job_threads=n_threads)

@follows(mkdir("snp"))
@transform(slamdunk_filter,
           regex("map/(.+).bam"),
           r"snp/\1_snp.vcf")
def slamdunk_snp(infiles, outfiles):
    '''slamdunk snp dunk'''
    genome_file = os.path.abspath(
        os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
    n_threads = PARAMS["number_of_threads"]
    out_dir = os.getcwd()+"/snp"
    job_memory="4G"
    statement = '''
    slamdunk snp -r %(genome_file)s 
                 -o %(out_dir)s 
                 -t %(n_threads)s 
                 %(infiles)s
    '''
    P.run(statement,
          job_memory="4G",
          job_threads=n_threads)

@transform(slamdunk_filter,
           regex("filter/(.+).bam"),
           r"filter/\1_dedup.bam")
def umi_dedup(infile, outfile):
    '''Deduplicates the BAM file using the UMI and position'''
    log_file = P.snip(outfile, ".bam")
    job_memory="4G"
    statement = '''
    umi_tools dedup -I %(infile)s 
                    -S %(outfile)s 
                    -L %(log_file)s
    '''
    P.run(statement,
          job_memory="4G")

@follows(slamdunk_snp, mkdir("count"))
@transform(umi_dedup,
           regex("map/(.+).bam"),
           r"count/\1_tcount.tsv")
def slamdunk_count(infiles, outfiles):
    '''slamdunk count dunk'''
    genome_file = os.path.abspath(
        os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
    n_threads = PARAMS["number_of_threads"]
    bed_file = PARAMS["bed_file_dir"]
    rl = PARAMS["max_read_length"]
    out_dir = os.getcwd()+"/count"
    snp_dir = str.join(os.getcwd(), "/snp")
    job_memory="4G"
    statement = '''
    slamdunk count -r %(genome_file)s 
                   -b %(bed_file)s  
                   -o %(out_dir)s 
                   -s %(snp_dir)s 
                   -m 
                   -l %(rl)s 
                   -t %(n_threads)s 
                   %(infiles)s
    '''
    P.run(statement,
          job_memory="4G",
          job_threads=n_threads)


@collate(slamdunk_count,
         regex("count/(.+)-(R.).+tsv"),
         r"count/\1-aggConvRate.tsv")
def merge_ConversionRate(infiles, outfile):
    '''Aggregate Conversion Rate of replicates into a single table'''
    infiles = str.join(" ", infiles)
    statement='''cgat combine_tables %(infiles)s
                    -S %(outfile)s -c 1,2,3,4,5,6 
                    -k 7 
                    --regex-filename='.+-(R[0-9]).+tsv' 
                    --use-file-prefix'''
    P.run(statement)


@collate(slamdunk_count,
         regex("count/(.+)-(R.).+tsv"),
         r"count/\1-aggReadsCPM.tsv")
def merge_CPM(infiles, outfile):
    '''Aggregate ReadsCPM of replicates'''
    infiles = str.join(" ", infiles)
    statement='''cgat combine_tables 
                     %(infiles)s 
                     -S %(outfile)s 
                     -c 1,2,3,4,5,6 
                     -k 8 
                     --regex-filename='.+-(R[0-9]).+tsv' 
                     --use-file-prefix'''
    P.run(statement)

@follows(mkdir("rates"))
@transform(slamdunk_filter,
           regex("filter/(.+).bam"),
           r"rates/\1_overallrates.csv")
def slamdunk_qc_rates(infiles,outfiles):
    '''Computes the overall conversion rates in your reads and plots them as a barplot'''
    genome_file = os.path.abspath(
        os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
    bed_file = PARAMS["bed_file_dir"]
    outfiles = os.path.dirname(os.path.abspath(outfiles))
    n_threads = PARAMS["number_of_threads"]
    job_memory="4G"
    statement = '''
    alleyoop rates -o %(outfiles)s 
                   -r %(genome_file)s 
                   -t %(n_threads)s 
                   %(infiles)s
    '''
    P.run(statement,
          job_memory="2G",
          job_threads=n_threads)


@follows(mkdir("utrrates"))
@transform(slamdunk_filter,
           regex("filter/(.+).bam"),
           r"utrrates/\1_mutationrates_utr.csv")
def slamdunk_qc_utrrates(infiles,outfiles):
    '''checks the individual conversion rates per 3’UTR and plots them as boxplots over the entire realm of 3’UTRs'''
    genome_file = os.path.abspath(os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
    bed_file = PARAMS["bed_file_dir"]
    outfiles = os.path.dirname(os.path.abspath(outfiles))
    n_threads = PARAMS["number_of_threads"]
    job_memory="2G"
    statement = '''
    alleyoop utrrates -o %(outfiles)s -r %(genome_file)s -t %(n_threads)s -b %(bed_file)s -l 50 %(infiles)s
    '''
    P.run(statement,
          job_memory="2G",
          job_threads=n_threads)


@transform(slamdunk_filter,
            suffix(".bam"),
            r"_summary.tsv")
def slamdunk_summary(infile,outfile):
    '''basic statistics of the mapping process'''
    statement = '''
    alleyoop summary -o %(outfile)s -t /count %(infile)s
    '''
    P.run(statement)


@merge(slamdunk_count,
       r"halflife.tsv")
def run_curvefit(infile, outfile):
    '''From count files, computes half lifes'''
    cdir = os.path.dirname(os.path.abspath(infile))
    threshold = PARAMS["cpm_threshold"]
    bg_sub = PARAMS["background"]
    script_path = os.path.join(os.dirname(os.abspath(__file__)), 
                               "Rscripts",
                               "slampy_seprep_withbed.R")
    statement = '''Rscript %(script_path)s
                         --count-directory %(cdir)s  
                         --cpm--threshold %(threshold)s 
                         --background %(bg_sub)s'''
    P.run(statement)


# @follows(mkdir("meme.dir"), run_curvefit)
# @transform("count/*.bed",
#            regex("count/(.+).bed"),
#            r"meme.dir/\1.fasta")
# def getfasta(infile, outfile):
#     '''From most and less stable bed file, get sequences and generate fasta for streme'''
#     genome_file = os.path.abspath(os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
#     statement = '''
#     cat %(infile)s | cgat bed2fasta -L bed2fasta.log --genome-file %(genome_file)s > %(outfile)s
#     '''
#     P.run(statement)

# @follows(getfasta)
# @transform("meme.dir/*.fasta",
#            regex("meme.dir/(.+).fasta"),
#            r"meme.dir/\1.dir")
# def streme(infile, outfile):
#     '''From most and less stable bed file, get sequences and generate fasta for streme'''
#     genome_file = os.path.abspath(os.path.join(PARAMS["genome_dir"], PARAMS["genome"] + ".fa"))
#     statement = '''
#     streme --p %(infile)s --minw 8 --maxw 15 --oc %(outfile)s
#     '''
#     P.run(statement,
#     job_memory="4G",
#     job_threads=2)

@follows(merge_ConversionRate,merge_CPM,slamdunk_qc_rates,slamdunk_qc_utrrates,slamdunk_summary,run_curvefit)
def full():
    '''Later alligator'''
    pass

P.main()
